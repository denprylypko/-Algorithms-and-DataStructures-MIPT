#  Реализация бинарного поиска O(log(2)*N)
# Требование: массив отсортирован (по возростанию)
"""A = [1, 3, 3, 6, 7, 9]

key - искомый элемент
если key = 5 - нет в массиве:
left_boundary = 3 - левая граница
right_boundary = 6 - правая граница

если key = 15 - нет в массиве:
left_boundary = 9 - левая граница
right_boundary = ? - правая граница: - указывает на позицию вне массива

если key = 3 - есть в массиве несколько елементов:
left_boundary = 1 - левая граница
right_boundary = 3 - правая граница (не 6)
"""
# def left_bound(A:list, key:int):	#Левая граница
# 	left = -1
# 	right = len(A)
# 	while right - left > 1:
# 		middle = (left + right) // 2
# 		if A[middle] < key:
# 			left = middle
# 		else:
# 			right = middle
# 	return left


# def right_bound(A:list, key:int):	#Правая граница
# 	left = -1
# 	right = len(A)
# 	while right - left > 1:
# 		middle = (left + right) // 2
# 		if A[middle] <= key:
# 			left = middle
# 		else:
# 			right = middle
# 	return right


# arr = [10, 12, 13, 15, 20, 24, 27, 33, 42, 51, 57, 68, 70, 77, 79, 81]

# l = left_bound(arr, 24)
# r = right_bound(arr, 24)
# print(l, r)
#-----------------------------------------------------------------------

# Динамическое программирование
""" Рекурентный алгоритм вычисления чисел Фибоначи:


"""
# def fib(n): # Очень медленно
# 	if n <= 1:
# 		return n
# 	return fib(n-2)+fib(n-1)
# print(fib(30))
"""
fib(4) --> fib(3) --> fib(2) --> fib(1) - Крайний случай
						\--> fib(0) - Также крайний случай

fib(2): fib(0) + fib(1) --> = 0 + 1 = 1
fib(3): fib(1) + fib(2) --> = 1 + 1 = 2
fib(4): fib(2) + fib(3) --> = 1 + 2 = 3

Функции вызываютс каждый раз по новой, делая перевычесления

Структура вызовов: Фибоначиевое дерево O(fib(n))
"""
"""
n 		0 1 2 3 ... n
fib(n) | | | | ... | |
# """
# n = 7
# fib = [0, 1] + [0]*(n-1)
# for i in range (2, n+1):
# 	fib[i] = fib[i-2]+fib[i-1]

# print(fib)

# # Перепищем в виде функции:
# def fib(n:int):
# 	fib = [0, 1] + [0]*(n-1)
# 	for i in range (2, n+1):
# 		fib[i] = fib[i-2]+fib[i-1]
# 	return fib[n]

# print(fib(7))

# Кузнечик
"""
0	 1
0----1----2----3----4----5----...----(N-2)----(N-1)----N - клеточки

Кузнечик находится в позиции 1
Кузьнечик может прыгать только вперед
Кузьнечик может прыгать с шагом: +1 или +2

Вопрос: сколько различных траекторий допрыгать из 1 в N?

Рассуждение: 
	в клетку N можно попасть только либо с клеточки N-1 либо N-2.

Следует что, количество траекторий: K[N] = K[N-2] + K[N-1]

def trajectory_number(N):
	k = [0, 1] + [0]*(N-1)
	for i in range(2, N+1):
		k[i] = k[i-2] + k[i-1]
	return(k[N])
"""

""" Изменим задачу:
Кузнечик находится в позиции 1
Кузьнечик может прыгать только вперед
Кузьнечик может прыгать с шагом: +1 или +2 или +3
!Запрещённые клеточки: 4 и 7
"""
# def count_trajectories(N, allowed:list): #allowed -list(bools)
# 	K = [0, 1, int(allowed[2])] + [0]*(N-2)
# 	for i in range(3, N+1):
# 		if allowed[i]:
# 			K[i] = K[i-1] + K[i-2] + K[i-3]
# 	return K[n]

#Минимальная стоимость достижения клетки N
#price[i] - цена за посещение клетки i
#В динамическом программировании есть крайний и рекурентный случаи
#C[i] - cost - суммарная минимальная стоимость достижения клетки і
""" Кузьнечику доступны шаги: +1 и +2
	C[i] = price[i] + min(C[i-1],C[i-2]) - рекурентная формула
	C[1] = price[1]
	C[2] = price[1] + price[2]
"""
# def count_min_cost(N:int, price:list):
# 	C = [float('-inf'), price[1], price[1]+price[2]] + [0]*(N-2)
# 	for i in range(3, N+1):
# 		C[i] = price[i] + min(price[i-1], price[i-2])
# 	return C[n]	#Наименшая стоимость

#------------------------------------------------------------------

# Двумерные массивы: (Nстрок, Mэлементов в строке)
# 1)Линеаризация двумерного массива: 
# (ширина массива должна быть зарание известна и зафиксирована)
# A[i,j] = A[i*M + j]

# 2) Создание списка списков
# N=3
# M = 3 
# A = [[0]*M]*N #!Так нельзя делать

# A = [[0]*M for i in range(N)]

# print(A)
# print(A[0])
# print(A[0][0])

# print(A[0] == A[1])	#True
# print(A[0] is A[1]) #False

# is - сравнивает ссылки на объектыл
